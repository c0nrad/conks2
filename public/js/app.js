// Generated by CoffeeScript 1.7.1
(function() {
  var Game, addCube, drawPlane, g, spawnMonster,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Game = (function() {
    function Game() {
      this.render = __bind(this.render, this);
      this.keyboardEvent = __bind(this.keyboardEvent, this);
      console.log("Initializing game...");
      this.initScene();
      this.initCamera();
      this.initRenderer();
      this.initEventHandlers();
      this.eventState = {
        UP: 0,
        LEFT: 0,
        DOWN: 0,
        RIGHT: 0,
        SPACEBAR: 0,
        STRAFE_LEFT: 0,
        STRAFE_RIGHT: 0
      };
      this.gameCounter = 1;
      drawPlane(this.scene);
      this.player = new Player(0, 0, this.scene);
      this.monsters = [];
      this.render();
    }

    Game.prototype.initScene = function() {
      this.scene = new THREE.Scene();
      return this.scene.add(new THREE.AmbientLight(0x404040));
    };

    Game.prototype.initCamera = function() {
      this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
      this.camera.position.y = -450;
      this.camera.position.z = 100;
      return this.camera.rotation.x = 45 * (Math.PI / 180);
    };

    Game.prototype.updateCamera = function() {
      var DISTANCE_ABOVE, DISTANCE_BEHIND, rotZ, x, y;
      DISTANCE_BEHIND = 200;
      DISTANCE_ABOVE = 200;
      rotZ = this.player.cube.rotation.z;
      x = this.player.cube.position.x;
      y = this.player.cube.position.y;
      this.camera.rotation.z = 0;
      this.camera.position.x = ((Math.sin(-rotZ)) * DISTANCE_BEHIND) + x;
      this.camera.position.y = ((Math.cos(-rotZ)) * DISTANCE_BEHIND) + y;
      this.camera.up.set(0, 0, 1);
      return this.camera.lookAt(this.player.cube.position);
    };

    Game.prototype.initRenderer = function() {
      this.renderer = new THREE.WebGLRenderer();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      return document.body.appendChild(this.renderer.domElement);
    };

    Game.prototype.initEventHandlers = function() {
      document.addEventListener("keydown", this.keyboardEvent, false);
      document.addEventListener("keyup", this.keyboardEvent, false);
      return document.addEventListener("click", this.mouseEvent, false);
    };

    Game.prototype.mouseEvent = function(e) {};

    Game.prototype.keyboardEvent = function(e) {
      var keyValue;
      keyValue = e.type === "keydown" ? 1 : 0;
      switch (e.keyCode) {
        case 81:
          return this.eventState.STRAFE_LEFT = keyValue;
        case 69:
          return this.eventState.STRAFE_RIGHT = keyValue;
        case 65:
        case 37:
          return this.eventState.LEFT = keyValue;
        case 87:
        case 38:
          return this.eventState.UP = keyValue;
        case 68:
        case 39:
          return this.eventState.RIGHT = keyValue;
        case 83:
        case 40:
          return this.eventState.DOWN = keyValue;
        case 32:
          return this.eventState.SPACEBAR = keyValue;
      }
    };

    Game.prototype.updateMonsters = function() {
      var b, bX, bY, i, m, mX, mY, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      if (this.gameCounter % 180 === 0) {
        for (i = _i = 1, _ref = this.gameCounter / 180; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          this.monsters.push(spawnMonster(this.scene));
        }
      }
      _ref1 = this.monsters;
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        m = _ref1[_j];
        m.update(this.player.cube.position.x, this.player.cube.position.y);
      }
      _ref2 = this.monsters;
      for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
        m = _ref2[_k];
        _ref3 = this.player.bullets;
        for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
          b = _ref3[_l];
          bX = b.cube.position.x;
          bY = b.cube.position.y;
          mX = m.cube.position.x;
          mY = m.cube.position.y;
          if (Math.sqrt(Math.pow(bX - mX, 2) + Math.pow(bY - mY, 2)) < 10) {
            m.remove();
            b.remove();
            m.alive = false;
            b.alive = false;
          }
        }
      }
      this.player.bullets = this.player.bullets.filter(function(b) {
        return b.alive;
      });
      return this.monsters = this.monsters.filter(function(b) {
        return b.alive;
      });
    };

    Game.prototype.gameOverCheck = function() {
      var m, mX, mY, pX, pY, _i, _len, _ref, _results;
      _ref = this.monsters;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        m = _ref[_i];
        pX = this.player.cube.position.x;
        pY = this.player.cube.position.y;
        mX = m.cube.position.x;
        mY = m.cube.position.y;
        if (Math.sqrt(Math.pow(pX - mX, 2) + Math.pow(pY - mY, 2)) < 10) {
          console.log("GAME OVER");
          _results.push(this.gameOver());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Game.prototype.render = function() {
      this.gameCounter += 1;
      requestAnimationFrame(this.render);
      this.gameOverCheck();
      this.player.update(this.eventState);
      this.updateCamera();
      this.updateMonsters();
      return this.renderer.render(this.scene, this.camera);
    };

    Game.prototype.gameOver = function() {
      var b, m, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.monsters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        m = _ref[_i];
        m.remove();
      }
      _ref1 = this.player.bullets;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        b = _ref1[_j];
        b.remove();
      }
      this.player.remove();
      this.gameCounter = 1;
      this.player = new Player(0, 0, this.scene);
      return this.monsters = [];
    };

    return Game;

  })();

  spawnMonster = function(scene) {
    var m, x, y;
    switch (Math.floor((Math.random() * 4) + 1)) {
      case 1:
        x = Math.floor((Math.random() * MAP_LENGTH) - MAP_LENGTH / 2);
        y = MAP_LENGTH / 2;
        break;
      case 2:
        y = Math.floor((Math.random() * MAP_LENGTH) - MAP_LENGTH / 2);
        x = MAP_LENGTH / 2;
        break;
      case 3:
        x = Math.floor((Math.random() * MAP_LENGTH) - MAP_LENGTH / 2);
        y = -MAP_LENGTH / 2;
        break;
      case 4:
        y = Math.floor((Math.random() * MAP_LENGTH) - MAP_LENGTH / 2);
        x = -MAP_LENGTH / 2;
    }
    m = new Monster(x, y, scene);
    return m;
  };

  addCube = function(x, y, z, color, scene) {
    var cube, geometry, material;
    geometry = new THREE.CubeGeometry(10, 10, 10);
    material = new THREE.MeshBasicMaterial({
      color: color
    });
    cube = new THREE.Mesh(geometry, material);
    scene.add(cube);
    return cube;
  };

  drawPlane = function(scene) {
    var plane;
    window.MAP_LENGTH = 500;
    plane = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshNormalMaterial());
    plane.overdraw = true;
    return scene.add(plane);
  };

  g = new Game();

  window.g = g;

}).call(this);
